name: 🚀 API Portal Deployment

on:
  push:
    paths:
      - 'environments/*.yaml'
    branches:
      - main

concurrency:
  group: api-portal-${{ github.ref }}
  cancel-in-progress: false  # Queue runs for infrastructure safety

permissions:
  contents: read

jobs:
  detect-environment:
    name: Detect deployment environment
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      deploy_dev: ${{ steps.detect.outputs.deploy_dev }}
      deploy_prod: ${{ steps.detect.outputs.deploy_prod }}
    
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed environment file
        id: detect
        run: |
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep "^environments/.*\.yaml$" || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "ℹ️ No environment files changed - skipping deployments"
            echo "deploy_dev=false" >> $GITHUB_OUTPUT
            echo "deploy_prod=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Determine which environments to deploy
          deploy_dev=false
          deploy_prod=false
          
          if echo "$CHANGED_FILES" | grep -q "environments/dev.yaml"; then
            echo "🚀 Detected DEV environment file change"
            if grep -q "^enabled: false" environments/dev.yaml; then
              echo "⏸️ DEV deployment is disabled"
            else
              deploy_dev=true
            fi
          fi
          
          if echo "$CHANGED_FILES" | grep -q "environments/prod.yaml"; then
            echo "🏭 Detected PROD environment file change"
            if grep -q "^enabled: false" environments/prod.yaml; then
              echo "⏸️ PROD deployment is disabled"
            else
              deploy_prod=true
            fi
          fi
          
          # Output deployment flags
          echo "deploy_dev=$deploy_dev" >> $GITHUB_OUTPUT
          echo "deploy_prod=$deploy_prod" >> $GITHUB_OUTPUT
          
          if [[ "$deploy_dev" == "false" && "$deploy_prod" == "false" ]]; then
            echo "ℹ️ No enabled environments to deploy"
            # Still exit successfully so the workflow doesn't fail
            exit 0
          fi

  deploy:
    name: Deploy API Portal
    needs: detect-environment
    runs-on: ubuntu-latest
    if: needs.detect-environment.outputs.deploy_dev == 'true' || needs.detect-environment.outputs.deploy_prod == 'true'
    permissions:
      id-token: write
      contents: read
    outputs:
      prod_deployed: ${{ steps.prod-deploy-check.outputs.deployed }}
      deployed_commit: ${{ steps.prod-deploy-check.outputs.commit }}
    strategy:
      matrix:
        include:
          - environment: dev
            config_file: environments/dev.yaml
            deploy_condition: ${{ needs.detect-environment.outputs.deploy_dev == 'true' }}
          - environment: prod
            config_file: environments/prod.yaml
            deploy_condition: ${{ needs.detect-environment.outputs.deploy_prod == 'true' }}
    env:
      CONFIG_FILE: ${{ matrix.config_file }}
    
    steps:
      - name: Check if this environment should deploy
        id: should-deploy
        run: |
          if [[ "${{ matrix.deploy_condition }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "✅ ${{ matrix.environment }} deployment enabled"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "⏸️ ${{ matrix.environment }} deployment skipped"
          fi

      - name: Check out repository
        if: steps.should-deploy.outputs.should_deploy == 'true'
        uses: actions/checkout@v4

      - name: Parse AWS configuration from YAML
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          echo "📋 Parsing AWS configuration from $CONFIG_FILE"
          
          # Extract AWS configuration using grep and awk
          AWS_REGION=$(grep -A 10 "^aws:" $CONFIG_FILE | grep "region:" | awk '{print $2}')
          AWS_ACCOUNT_ID=$(grep -A 10 "^aws:" $CONFIG_FILE | grep "account_id:" | awk '{print $2}' | tr -d '"')
          PIPELINE_EXECUTION_ROLE=$(grep -A 10 "^aws:" $CONFIG_FILE | grep "pipeline_execution_role:" | sed 's/.*pipeline_execution_role: //' | tr -d '"' | xargs)
          CLOUDFORMATION_EXECUTION_ROLE=$(grep -A 10 "^aws:" $CONFIG_FILE | grep "cloudformation_execution_role:" | sed 's/.*cloudformation_execution_role: //' | tr -d '"' | xargs)
          ARTIFACTS_BUCKET=$(grep -A 10 "^aws:" $CONFIG_FILE | grep "artifacts_bucket:" | awk '{print $2}')
          
          # Export to environment
          echo "AWS_REGION=$AWS_REGION" >> $GITHUB_ENV
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
          echo "PIPELINE_EXECUTION_ROLE=$PIPELINE_EXECUTION_ROLE" >> $GITHUB_ENV
          echo "CLOUDFORMATION_EXECUTION_ROLE=$CLOUDFORMATION_EXECUTION_ROLE" >> $GITHUB_ENV
          echo "ARTIFACTS_BUCKET=$ARTIFACTS_BUCKET" >> $GITHUB_ENV
          
          # Debug: Verify values were extracted correctly
          if [ -z "$AWS_REGION" ] || [ -z "$AWS_ACCOUNT_ID" ] || [ -z "$PIPELINE_EXECUTION_ROLE" ]; then
            echo "❌ Failed to extract AWS configuration from YAML"
            echo "AWS_REGION: $AWS_REGION"
            echo "AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
            echo "PIPELINE_EXECUTION_ROLE: $PIPELINE_EXECUTION_ROLE"
            exit 1
          fi
          
          # Debug: Show extracted role ARN
          echo "🔍 Extracted PIPELINE_EXECUTION_ROLE: $PIPELINE_EXECUTION_ROLE"
          
          
          # Extract stack name
          STACK_NAME=$(grep "^stack_name:" $CONFIG_FILE | cut -d' ' -f2)
          echo "STACK_NAME=$STACK_NAME" >> $GITHUB_ENV
          echo "CONFIG_FILE=$CONFIG_FILE" >> $GITHUB_ENV
          
          # Replace GitHub SHA in rebuild token
          sed -i "s/\${GITHUB_SHA}/${{ github.sha }}/g" $CONFIG_FILE
          
          echo "📋 Deployment Configuration:"
          echo "  Stack: $STACK_NAME"
          echo "  Region: $AWS_REGION"
          echo "  Account: $AWS_ACCOUNT_ID"

      # Skip npm install and frontend build - SAM handles everything
      # The React app is already built and checked into lambdas/static-asset-uploader/build/

      - name: Set up SAM CLI
        if: steps.should-deploy.outputs.should_deploy == 'true'
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Configure AWS credentials
        if: steps.should-deploy.outputs.should_deploy == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.PIPELINE_EXECUTION_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: api-portal-deploy
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Deploy with SAM
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          echo "🚀 Deploying stack: ${STACK_NAME}"
          echo "📦 Region: ${AWS_REGION}"
          
          # Build parameter overrides
          PARAMS=""
          while IFS=: read -r line; do
            # Skip empty lines
            if [[ -z "$line" ]] || [[ "$line" =~ ^[[:space:]]*$ ]]; then
              continue
            fi
            
            # Skip comment lines (lines that start with # after optional whitespace)
            if [[ "$line" =~ ^[[:space:]]*# ]]; then
              continue
            fi
            
            # Extract key and value
            key=$(echo "$line" | cut -d: -f1 | xargs)
            # Extract value and remove inline comments
            value=$(echo "$line" | cut -d: -f2- | cut -d'#' -f1 | xargs)
            
            # Skip if key is empty or doesn't start with a letter
            if [[ -z "$key" ]] || ! [[ "$key" =~ ^[A-Za-z][A-Za-z0-9_]*$ ]]; then
              continue
            fi
            
            # Add to parameters if value exists
            if [[ -n "$value" ]]; then
              PARAMS="$PARAMS $key=$value"
            fi
          done < <(grep -A 50 "^parameters:" $CONFIG_FILE | tail -n +2)
          
          # Debug: Show final parameters
          echo "📋 Final parameter overrides: $PARAMS"
          
          # Build the SAM application
          echo "🔨 Building SAM application..."
          sam build \
            --template-file cloudformation/template.yaml \
            --use-container
          
          # Deploy the application
          sam deploy \
            --template-file .aws-sam/build/template.yaml \
            --stack-name ${STACK_NAME} \
            --capabilities CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND \
            --region ${AWS_REGION} \
            --s3-bucket ${ARTIFACTS_BUCKET} \
            --no-fail-on-empty-changeset \
            --role-arn ${CLOUDFORMATION_EXECUTION_ROLE} \
            --parameter-overrides $PARAMS

      - name: Get deployment outputs
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          # Get stack outputs
          WEBSITE_URL=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --region ${AWS_REGION} \
            --query 'Stacks[0].Outputs[?OutputKey==`WebsiteURL`].OutputValue' \
            --output text)
          
          echo "🌐 Developer Portal URL: ${WEBSITE_URL}"
          echo "WEBSITE_URL=${WEBSITE_URL}" >> $GITHUB_ENV

      - name: Track production deployment status
        id: prod-deploy-check
        if: matrix.environment == 'prod' && steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          echo "deployed=true" >> $GITHUB_OUTPUT
          echo "commit=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "✅ Production deployment successful at commit ${{ github.sha }}"

      - name: Mark job as skipped if no deployment
        if: steps.should-deploy.outputs.should_deploy != 'true'
        run: |
          echo "::notice::Deployment was skipped for ${{ matrix.environment }}"
          # Exit successfully to avoid failing the matrix


  # DNS configuration is now handled by CloudFormation using the HostedZoneName parameter
  # The CustomDomainRecordSet resource creates the DNS A record automatically

  skip-message:
    name: Deployment Skipped
    needs: detect-environment
    runs-on: ubuntu-latest
    if: needs.detect-environment.outputs.deploy_dev == 'false' && needs.detect-environment.outputs.deploy_prod == 'false'
    
    steps:
      - name: Show skip message
        run: |
          echo "⏸️ No deployments were triggered"
          echo ""
          echo "Possible reasons:"
          echo "- All environments have 'enabled: false'"
          echo "- No environment files were changed"
          echo ""
          echo "To enable deployment:"
          echo "1. Edit environments/dev.yaml or environments/prod.yaml"
          echo "2. Change 'enabled: false' to 'enabled: true'"
          echo "3. Commit and push the change"
          echo ""
          echo "This is a safety feature to prevent accidental deployments."

  release:
    name: Create release
    needs: [deploy]
    runs-on: ubuntu-latest
    if: needs.deploy.outputs.prod_deployed == 'true'
    permissions:
      contents: write
      issues: write
      pull-requests: write
    
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.deploy.outputs.deployed_commit }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Install dependencies
        run: poetry install

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Verify commit matches deployment
        run: |
          CURRENT_SHA=$(git rev-parse HEAD)
          EXPECTED_SHA="${{ needs.deploy.outputs.deployed_commit }}"
          
          if [ "$CURRENT_SHA" != "$EXPECTED_SHA" ]; then
            echo "❌ ERROR: Commit mismatch!"
            echo "Current commit: $CURRENT_SHA"
            echo "Expected commit: $EXPECTED_SHA"
            exit 1
          fi
          
          echo "✅ Verified: Running semantic-release on the deployed commit"
          echo "Commit SHA: $CURRENT_SHA"

      - name: Run semantic release
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "🚀 Running semantic release..."
          poetry run semantic-release version
          
          # Get the new version if created
          NEW_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ ! -z "$NEW_VERSION" ]; then
            echo "📦 New version: ${NEW_VERSION}"
            echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV
          fi

      - name: Push changes
        if: env.NEW_VERSION != ''
        run: |
          echo "📤 Pushing version bump and tags..."
          
          if ! git push --follow-tags origin main; then
            echo "❌ Failed to push version bump to main"
            echo ""
            echo "This happens when another commit was pushed to main during our workflow."
            echo "Since we only release the exact commit that was deployed, we cannot"
            echo "resolve this automatically without compromising release integrity."
            echo ""
            echo "Resolution: Re-run this workflow to try again with the latest code."
            exit 1
          fi
          
          echo "✅ Successfully pushed version ${NEW_VERSION}"

      - name: Create GitHub release
        if: env.NEW_VERSION != ''
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "🏷️ Creating GitHub release for version ${NEW_VERSION}..."
          
          RELEASE_NOTES="API Portal Release ${NEW_VERSION}
          
          ## 🚀 Deployment Details
          - **Environment**: Production
          - **Stack**: ${{ env.STACK_NAME }}
          - **Portal URL**: ${{ env.WEBSITE_URL }}
          
          ## 📦 Changes
          See [CHANGELOG.md](CHANGELOG.md) for detailed changes."
          
          # Check if release already exists
          if gh release view "${NEW_VERSION}" >/dev/null 2>&1; then
            echo "📝 Release ${NEW_VERSION} already exists, updating..."
            gh release edit "${NEW_VERSION}" \
              --title "Release ${NEW_VERSION}" \
              --notes "${RELEASE_NOTES}"
          else
            echo "✨ Creating new release ${NEW_VERSION}..."
            gh release create "${NEW_VERSION}" \
              --title "Release ${NEW_VERSION}" \
              --notes "${RELEASE_NOTES}" \
              --latest
          fi